<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../mixins-audiovideo.html">

<!-- Media Encoder WebM -->
<script src="../../bower_components/whammy/whammy.js"></script>

<polymer-element name="ivx-core-video" extends="ivx-core-image" constructor="IvxCoreVideo" attributes="">
  <script>
    (function () {

      Polymer(Polymer.mixin({
        _videoBlob: null,
        _videoFrames: [],
        _rafId: null,
        _fps: 0,
        _recordedCallback: null,

        /**
         * Returns `true` if the `MediaStreamTrack API` is supported by the current used browser. False otherwise.
         *
         * @return {Boolean} true if the browser is supported, false otherwise.
         */
        isSupported: function() {
          this.super();
        },

        getRecordedBlob: function(callback) {
          this._recordedCallback = callback;
        },

        // ===== private methods =====
        _stateChanged: function() {
          switch (this._state) {
            case this._stateEnum.RECORDING:
              this._onRecordingStarted();
              break;
            case this._stateEnum.STOPPED:
              this._onRecordingStopped();
              break;
            default:
              break;
          }
        },

        _onRecordingStarted: function() {
          this._videoBlob = null; // reset blob
          this._recordedBlobCallback = null,
          this._videoFrames = [];

          // draw the current video frame into the canvas 2D context to read them back as image.
          function drawVideoFrame() {
            this._rafId = requestAnimationFrame((drawVideoFrame).bind(this)); // cross browser safe!
            //this._canvas.getContext('2d').drawImage(this._id('#liveVideo'), 0, 0, this._canvas.width, this._canvas.height);
            this._drawImage();

            // Read back canvas as webp.
            //var url = this._canvas.toDataURL('image/webp', 0.80); // image/jpeg is a way faster :(
            var url = this.getPictureDataURL('image/webp', 0.80);
            this._videoFrames.push(url);
          };

          // request the first frame
          this._rafId = requestAnimationFrame((drawVideoFrame).bind(this));
        },

        _onRecordingStopped: function() {
          cancelAnimationFrame(this._rafId);
          // adjust the recorded frames to the duration to get the real speed
          this._fps = Math.floor(this._videoFrames.length / (this.getDuration() / 1000));

          this.async(function() {
            this._videoBlob = Whammy.fromImageArray(this._videoFrames, this._fps);
            this._recordedCallback({
              blob: this._videoBlob,
              frames: this._videoFrames.length,
              fps: this._fps
            });
          });
        }
      }, mixinsCore, mixinsAudioVideo));

    })();
  </script>
</polymer-element>
